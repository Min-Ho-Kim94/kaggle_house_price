---
title: "house_price"
output:
  word_document:
    toc: yes
    toc_depth: '3'
  pdf_document:
    toc: yes
    toc_depth: '3'
  html_document:
    number_sections: yes
    toc: yes
    toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

kaggle address : https://www.kaggle.com/zizonpingu

# Data load 

```{r}
library(tidyverse)
library(plyr)
library(scales)
library(knitr)
library(gridExtra)
library(corrplot)
library(ggrepel)
library(caret)
library(xgboost)
```

```{r warning=TRUE}
train <- read.csv("~/Github/kaggle_house_price/house-prices-advanced-regression-techniques/train.csv", stringsAsFactors = F)
test <- read.csv("~/Github/kaggle_house_price/house-prices-advanced-regression-techniques/test.csv", stringsAsFactors = F)

str(train)
names(train)
```

```{r}
test$SalePrice <- NA
all <- rbind(train,test)
names(all)
```


# target variable

## SalePrice - target variable

```{r}
summary(all$SalePrice)

ggplot(all[!is.na(all$SalePrice),], aes(x=SalePrice)) +
  geom_histogram(fill="red") +
  scale_x_continuous(breaks = seq(0,800000, by=100000), labels = scales::comma) #library(scales)
```

SalePrice의 분포를 보면, right-skewed된 분포임을 알 수 있다. 분산 안정화를 위해 log를 취하여 그래프를 그려보면,


```{r}
summary(log(all$SalePrice))

ggplot(all[!is.na(all$SalePrice),], aes(x=log(SalePrice))) +
  geom_histogram(fill="red") +
  scale_x_continuous(breaks = seq(10,15, by=0.25))
```

평균이 12.02이고 어느 쪽으로 skewed된 경향이 감소했음을 알 수 있었다.

# Exploring data (Imputation) 

## imputation {.tabset}

이제 variables를 살펴보기 전에, 결측값이 존재하는지 아닌지 알아보았다.

```{r}
NAs <- function(df){
  aa <- sapply(df, function(x){sum(is.na(x))})
  return(sort(aa[which(aa>0)], decreasing = T))
}

NAs(all)
```
 
관련있는 변수끼리 묶에 결측치 처리 (imputation)을 한다.
참고로 SalePrice의 1459개는 test의 갯수로 예측해야 하는 종속변수이므로 imputation하지 않는다.

```{r}
nrow(all[!complete.cases(all),])
sum(!complete.cases(all))
```

결측치가 없는 행의 개수를 출력할 때 complete.cases()를 사용한다.

### Pool
PoolQC : Pool quality

       Ex	Excellent
       Gd	Good
       TA	Average/Typical
       Fa	Fair
       NA	No Pool
       
PoolQC는 전체 2919개 중 10개를 제외한 나머지는 결측으로 처리되어 있다. 이를 NA에서 None 즉 pool이 없다고 바꿔준다.

```{r}
all$PoolQC[is.na(all$PoolQC)] <- 'None'
```

* 에러가 날 경우 


    invalid factor level, NA generated
    

이거는 이미 PoolQC의 class가 factor이며, level이 Ex, Fa, Gd로 설정되있는 상태에서, None 이라는 새로운 level을 넣을 경우 에러로 뜬다. 따라서 처음 데이터를 불러올 때 "stringsAsFactors = F" 설정을 넣어 str class로 범주형 변수를 불러온다. (그 증거로, "stringsAsFactors = F" 없는 경우 str() 함수를 쓸 경우 범주형 변수가 Factor로 설정되는 반면, "stringsAsFactors = F" 있는 경우 범주형 변수가 str 형식으로 설정된다.) 그런 뒤 각 변수의 imputation과정을 거치고 factor로 바꿔준다.

그런 뒤 새로 Factor로 변환시키는데, level을 지정해준다. 순서형 변수이므로 순서로 변환.

```{r}
library(plyr)
Qualities <- c('None'=0, 'Po'=1, "Fa"=2, "TA"=3, "Gd"=4, "Ex"=5)
all$PoolQC <- as.integer(revalue(all$PoolQC, replace=Qualities))
table(all$PoolQC)
```


PoolArea 에 값이 있으면 PoolQC는 무조건 1 이상이어야 하지만, 0의 값을 갖는 값들이 있었다. 

```{r}
all[all$PoolArea>0 & all$PoolQC==0, c("PoolArea","PoolQC","OverallQual")]
```
 
이를 보정해주었다. OverallQual은 집의 전반적인 퀄리티를 나타내는 변수로, 이를 이용해 적절하게 보정하였다.

```{r}
all$PoolQC[2421] <- 2
all$PoolQC[2504] <- 3
all$PoolQC[2600] <- 2
```
 
### Miscellaneous

       Elev	Elevator
       Gar2	2nd Garage (if not described in garage section)
       Othr	Other
       Shed	Shed (over 100 SF)
       TenC	Tennis Court
       NA	None

```{r}
all$MiscFeature[is.na(all$MiscFeature)] <- 'None'
all$MiscFeature <- as.factor(all$MiscFeature)

library(scales)
ggplot(all[!is.na(all$SalePrice),], aes(x=MiscFeature, y=SalePrice)) +
  geom_bar(stat='summary', fun.y='median', fill='blue') +
  scale_y_continuous(breaks = seq(0,800000, by=100000), labels = scales::comma) +
  geom_label(stat="count", aes(label=..count.., y=..count..))

```


### Alley

       Grvl	Gravel
       Pave	Paved
       NA 	No alley access

```{r}
all %>% group_by(Alley) %>% summarize(count = count(Alley))

all$Alley[is.na(all$Alley)] <- 'None'
all$Alley <- as.factor(all$Alley)

ggplot(all[!is.na(all$SalePrice),], aes(x=Alley, y=SalePrice)) +
  geom_bar(stat='summary', fun.y='median', fill='blue') +
  scale_y_continuous(breaks=seq(0,200000, by=50000), labels = scales::comma)



```


### Fence

    GdPrv    Good Privacy
    MnPrv    Minimum Privacy
    GdWo Good Wood
    MnWw Minimum Wood/Wire
    NA   No Fence

```{r}
all %>% group_by(Fence) %>% summarise(count(Fence))
```

 
```{r}
all$Fence[is.na(all$Fence)] <- 'None'
all$Fence <- as.factor(all$Fence)

ggplot(all[!is.na(all$SalePrice),], aes(x=Fence, y=SalePrice)) +
  geom_bar(stat='summary', fun.y='median', fill='blue')
```
 

### Fireplace

    Ex   Excellent - Exceptional Masonry Fireplace
    Gd   Good - Masonry Fireplace in main level
    TA   Average - Prefabricated Fireplace in main living area or Masonry Fireplace in basement
    Fa   Fair - Prefabricated Fireplace in basement
    Po   Poor - Ben Franklin Stove
    NA   No Fireplace


```{r}
all %>% group_by(FireplaceQu) %>% summarize(count(FireplaceQu))
all$FireplaceQu[is.na(all$FireplaceQu)] <- 'None'
# Qualities None   Po   Fa   TA   Gd   Ex 
#                0    1    2    3    4    5 

all$FireplaceQu <- as.factor(revalue(all$FireplaceQu , replace=Qualities))
```
 
```{r}
ggplot(all[!is.na(all$SalePrice),], aes(x=FireplaceQu, y=SalePrice)) +
  geom_bar(stat='summary', fun.y='median', fill='blue') +
  scale_y_continuous(breaks=seq(0, 400000, by=50000), labels=comma)
```

### lot

**LotFrontage : linear feet of street connected to property **

```{r}
#all %>% group_by(LotFrontage) %>% summarise(count(LotFrontage))

ggplot(all, aes(x=LotFrontage)) +
  geom_histogram(fill='blue', binwidth = 4) +
  scale_x_continuous(breaks=seq(0,320,by=20))
  
```

486 NAs. The most reasonable imputation seems to take the median per neigborhood.

```{r}
ggplot(all[!is.na(all$LotFrontage),], aes(x=as.factor(Neighborhood), y=LotFrontage)) +
        geom_bar(stat='summary', fun.y = "median", fill='blue') +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
for (i in 1:nrow(all)){
        if(is.na(all$LotFrontage[i])){
               all$LotFrontage[i] <- as.integer(median(all$LotFrontage[all$Neighborhood==all$Neighborhood[i]], na.rm=TRUE)) 
        }
}
```

**LotShape: General shape of property**

No NAs. Values seem ordinal (Regular=best)

       Reg	Regular	
       IR1	Slightly irregular
       IR2	Moderately Irregular
       IR3	Irregular

```{r}
all$LotShape<-as.integer(revalue(all$LotShape, c('IR3'=0, 'IR2'=1, 'IR1'=2, 'Reg'=3)))
table(all$LotShape)
sum(table(all$LotShape))
```


### Garage 

Garage에 관련된 변수는 총 7개로 GarageType, GarageYrBlt, GarageFinish, GarageCars, GarageArea, GarageQual, GaragaCond이다. 각각은 다 결측이 있었으므로 imputation을 실행하기로 했다. 


```{r}
NAs(all[,grep("^Garage",names(all))])
```

grep 함수와 NAs 함수로 Garage로 시작하는 변수의 NA 개수를 반환하게 한다.

**GarageYrBlt**

먼저 GarageYrBlt를 보면, 집이 지어졌을 때와 집이 리모델링했을 때를 나타내는 (각각 YearBuilt, YearRemodAdd) 변수랑 비교해보았다. 만약 리모델링을 하지 않았다면 YearRemodAdd는 YearBuilt와 값이 같다.

```{r}
nrow(all)
c(length(which(all$YearBuilt==all$YearRemodAdd)), length(which(all$YearBuilt==all$YearRemodAdd))/nrow(all))
c(length(which(all$YearBuilt==all$GarageYrBlt)), length(which(all$YearBuilt==all$GarageYrBlt))/nrow(all))
```
전체 2919중 집이 지어진 연도와 리모델링 연도가 같은 데이터는 1560개로 전체 53%이고 (즉 리모델링하지 않은 집이 53%), 집을 지을때 차고를 같이 지은 집은 2216개로 전체 약 75%였다. 따라서 159개의 GarageYrBlt 결측치는 집을 지을 때 차고도 같이 지었다고 imputation 하였다. 즉,

```{r}
all$GarageYrBlt[is.na(all$GarageYrBlt)] <- all$YearBuilt[is.na(all$GarageYrBlt)]
```

**GarageCars, GarageArea**

다음으로, GarageType은 157개의 결측인데, 다른 159개의 결측치와 다른 2개가 무엇인지 데이터 탐색을 실행해보았다.

```{r}
length(which(is.na(all$GarageType) & is.na(all$GarageFinish) & is.na(all$GarageCond) & is.na(all$GarageQual)))

all[!is.na(all$GarageType) & is.na(all$GarageFinish), c('GarageCars', 'GarageArea', 'GarageType', 'GarageCond', 'GarageQual', 'GarageFinish')]
```

2127와 2577번 째 관찰값은 GarageCond, GarageQual, GarageFinish가 결측임에도 불구하고 GarageType이 Detchd로 값이 존재했다. 또한 2577은 GarageCars, GarageArea도 결측이었다. 2127은 차고가 있는 것, 2577은 차고가 없는 것으로 판단하여 2127에 GarageCond, GarageQual, GarageFinish를 보정하였고, 2577의 GarageType은 NA로 대체하였다.


```{r}
#modes.
all$GarageCond[2127] <- names(sort(-table(all$GarageCond)))[1]
all$GarageQual[2127] <- names(sort(-table(all$GarageQual)))[1]
all$GarageFinish[2127] <- names(sort(-table(all$GarageFinish)))[1]

all[2127, c('GarageYrBlt', 'GarageCars', 'GarageArea', 'GarageType', 'GarageCond', 'GarageQual', 'GarageFinish')]
```

```{r}
all$GarageCars[2577] <- 0
all$GarageArea[2577] <- 0
all$GarageType[2577] <- NA

all[2577, c('GarageYrBlt', 'GarageCars', 'GarageArea', 'GarageType', 'GarageCond', 'GarageQual', 'GarageFinish')]

length(which(is.na(all$GarageType) & is.na(all$GarageFinish) & is.na(all$GarageCond) & is.na(all$GarageQual)))
NAs(all[,grep("^Garage",names(all))])
```



**GarageType**

       2Types	More than one type of garage
       Attchd	Attached to home
       Basment	Basement Garage
       BuiltIn	Built-In (Garage part of house - typically has room above garage)
       CarPort	Car Port
       Detchd	Detached from home
       NA	No Garage
       
차고가 없음은 NA에서 No Garage 으로 바꿔주었다.


```{r}
all$GarageType[is.na(all$GarageType)] <- 'No Garage'
all$GarageType <- as.factor(all$GarageType)
table(all$GarageType)
```

**GarageFinish: Interior finish of the garage**

       Fin	Finished
       RFn	Rough Finished	
       Unf	Unfinished
       NA	No Garage       

차고 인테리어 마감 정도는 순서형(ordinal) 이므로 순서형으로 코딩하였다.

```{r}
all$GarageFinish[is.na(all$GarageFinish)] <- 'None'
Finish <- c('None'=0, 'Unf'=1, 'RFn'=2, 'Fin'=3)

all$GarageFinish<-as.integer(revalue(all$GarageFinish, Finish))
table(all$GarageFinish)
```

**GarageQual: Garage quality**


       Ex	Excellent
       Gd	Good
       TA	Typical/Average
       Fa	Fair
       Po	Poor
       NA	No Garage
       
```{r}
all$GarageQual[is.na(all$GarageQual)] <- 'None'
all$GarageQual<-as.integer(revalue(all$GarageQual, Qualities))
table(all$GarageQual)
```

**GarageCond: Garage condition**

       Ex	Excellent
       Gd	Good
       TA	Typical/Average
       Fa	Fair
       Po	Poor
       NA	No Garage

```{r}
all$GarageCond[is.na(all$GarageCond)] <- 'None'
all$GarageCond<-as.integer(revalue(all$GarageCond, Qualities))
table(all$GarageCond)
```


### Basement Variables

**11개 변수에 대해결측 처리**

Five of those have 79-82 NAs, six have one or two NAs.

BsmtFinType1이 79개 결측치를 가졌다. 
5개 변수가 같은 NA를 가지는 행인지 알아보고, 그렇지 않은 행을 추출해보면,
```{r}
##### highlight
length(which(is.na(all$BsmtQual) & is.na(all$BsmtCond) & is.na(all$BsmtExposure) & is.na(all$BsmtFinType1) & is.na(all$BsmtFinType2)))

all[!is.na(all$BsmtFinType1) & (is.na(all$BsmtCond)|is.na(all$BsmtQual)|is.na(all$BsmtExposure)|is.na(all$BsmtFinType2)), 
    c('BsmtQual', 'BsmtCond', 'BsmtExposure', 'BsmtFinType1', 'BsmtFinType2')] 
```

9개 관찰값의 각 NA를 각 변수의 최빈값으로 보정해주었다.

```{r}
#Imputing modes.
##### hightlight
all$BsmtFinType2[333] <- names(sort(-table(all$BsmtFinType2)))[1]
all$BsmtExposure[c(949, 1488, 2349)] <- names(sort(-table(all$BsmtExposure)))[1]
all$BsmtCond[c(2041, 2186, 2525)] <- names(sort(-table(all$BsmtCond)))[1]
all$BsmtQual[c(2218, 2219)] <- names(sort(-table(all$BsmtQual)))[1]
```

이제 공통적인 79개에 대한 결측치를 보정한다.

**BsmtQual: Evaluates the height of the basement**

A variable than can be made ordinal with the Qualities vector.

       Ex	Excellent (100+ inches)	
       Gd	Good (90-99 inches)
       TA	Typical (80-89 inches)
       Fa	Fair (70-79 inches)
       Po	Poor (<70 inches
       NA	No Basement

```{r, message=FALSE}
all$BsmtQual[is.na(all$BsmtQual)] <- 'None'
all$BsmtQual<-as.integer(revalue(all$BsmtQual, Qualities))
table(all$BsmtQual)
```
		
**BsmtCond: Evaluates the general condition of the basement**

A variable than can be made ordinal with the Qualities vector.

       Ex	Excellent
       Gd	Good
       TA	Typical - slight dampness allowed
       Fa	Fair - dampness or some cracking or settling
       Po	Poor - Severe cracking, settling, or wetness
       NA	No Basement

```{r, message=FALSE}
all$BsmtCond[is.na(all$BsmtCond)] <- 'None'
all$BsmtCond<-as.integer(revalue(all$BsmtCond, Qualities))
table(all$BsmtCond)
```
	
**BsmtExposure: Refers to walkout or garden level walls**

A variable than can be made ordinal.

       Gd	Good Exposure
       Av	Average Exposure (split levels or foyers typically score average or above)	
       Mn	Mimimum Exposure
       No	No Exposure
       NA	No Basement

```{r}
all$BsmtExposure[is.na(all$BsmtExposure)] <- 'None'
Exposure <- c('None'=0, 'No'=1, 'Mn'=2, 'Av'=3, 'Gd'=4)

all$BsmtExposure<-as.integer(revalue(all$BsmtExposure, Exposure))
table(all$BsmtExposure)
```
       
**BsmtFinType1: Rating of basement finished area**

A variable than can be made ordinal.

       GLQ	Good Living Quarters
       ALQ	Average Living Quarters
       BLQ	Below Average Living Quarters	
       Rec	Average Rec Room
       LwQ	Low Quality
       Unf	Unfinshed
       NA	No Basement
		
```{r}
all$BsmtFinType1[is.na(all$BsmtFinType1)] <- 'None'
FinType <- c('None'=0, 'Unf'=1, 'LwQ'=2, 'Rec'=3, 'BLQ'=4, 'ALQ'=5, 'GLQ'=6)

all$BsmtFinType1<-as.integer(revalue(all$BsmtFinType1, FinType))
table(all$BsmtFinType1)
```

**BsmtFinType2: Rating of basement finished area (if multiple types)**

A variable than can be made ordinal with the FinType vector.

       GLQ	Good Living Quarters
       ALQ	Average Living Quarters
       BLQ	Below Average Living Quarters	
       Rec	Average Rec Room
       LwQ	Low Quality
       Unf	Unfinshed
       NA	No Basement

```{r}
all$BsmtFinType2[is.na(all$BsmtFinType2)] <- 'None'
FinType <- c('None'=0, 'Unf'=1, 'LwQ'=2, 'Rec'=3, 'BLQ'=4, 'ALQ'=5, 'GLQ'=6)

all$BsmtFinType2<-as.integer(revalue(all$BsmtFinType2, FinType))
table(all$BsmtFinType2)
```

여기까지 데이터 중 결측이 하나라도 없는 행의 갯수를 알아보면,
```{r}
sum(complete.cases(subset(all, select=-c(SalePrice))))

which(complete.cases(subset(all,select=-c(SalePrice)))==F) #obs of NAs 
```

전체 2919개 중 2883개(전체 중 98.77%)이다.


## classifying variable classes and encoding {.tabset}

all 에는 character, numeric, 그리고 이미 변환한 Factor class로 이루어져 있다. 이를 분류하면,

```{r}
chrvar <- names(all[,sapply(all,is.character)])
chrvar
numvar <- names(all[,sapply(all,is.numeric)])
numvar
facvar <- names(all[,sapply(all,is.factor)])
facvar

sum(length(chrvar),length(numvar),length(facvar)) #81
```


**numeric class**
수치형 변수가 SalePrice와 어느정도 상관관계가 있는지 알아보기 위해 corrplot을 그려보면,
```{r}
cor <- cor(all[,numvar], use = "pairwise.complete.obs")
cor_sort <- as.matrix(sort(cor[,'SalePrice'], decreasing = TRUE))
corhigh <- names(which(apply(cor_sort,1,function(x) abs(x)>0.5)))

cor <- cor[corhigh,corhigh]

corrplot.mixed(cor,tl.col="black", tl.pos = "lt")
```

SalePrice에 관련해서 가장 correlation이 높은 변수는 OverallQual, GrLivArea, GarageCars, GarageArea, TotalBsmtSF 등 순이었다. 그 중 GarageCars와 GarageArea는 0.89로 모든 변수들 중 가장 높은 corr을 가졌고, GrLivArea와 TotRmsAbvGrd도 0.81로 corr이 높았다.


SalePrice와 OverallQual 간 plot
```{r}
ggplot(data=all[!is.na(all$SalePrice),], aes(x=factor(OverallQual), y=SalePrice))+
        geom_boxplot(col='deepskyblue3') + labs(x='Overall Quality') +
        scale_y_continuous(breaks= seq(0, 800000, by=100000), labels = comma)
```

Overall Quality가 증가할수록 SalePrice가 점점 증가하는 꼴을 볼 수 있다.  
OverallQual=4일 경우 이상치가 존재하는 것 같다.


SalePrice와 GrLivArea 간 plot 
```{r}
ggplot(data=all[!is.na(all$SalePrice),], aes(x=GrLivArea, y=SalePrice))+
        geom_point(col='deepskyblue3') + geom_smooth(method = "lm", se=FALSE, color="black", aes(group=1)) +
        scale_y_continuous(breaks= seq(0, 800000, by=100000), labels = comma) +
        geom_text_repel(aes(label = ifelse(all$GrLivArea[!is.na(all$SalePrice)]>4500, rownames(all), '')))
```


524와 1299번째 관찰값은 선에서 많이 벗어난 것 처럼 보인다. 즉, GrLivArea가 넓음에도 불구하고, SalePrice가 낮은 경우이다. 이 집들의 OverallQual을 본다면,
```{r}
all[c(524, 1299),c("SalePrice", "GrLivArea", "OverallQual")]
```
전체적인 퀄리티도 10으로 가장 높은 점수를 형성하지만, SalePrice는 낮다.


이제, Collinearity를  

```{r}

```


  
