---
title: "house_price"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Data load & Exploring

```{r}
library(tidyverse)
```

```{r}
train <- read.csv("~/Github/kaggle_house_price/house-prices-advanced-regression-techniques/train.csv", stringsAsFactors = F)
test <- read.csv("~/Github/kaggle_house_price/house-prices-advanced-regression-techniques/test.csv", stringsAsFactors = F)

str(train)
names(train)
```

```{r}
test$SalePrice <- NA
all <- rbind(train,test)
names(all)
```
variable descriptions [link]()


## attributes values & target variable

# SalePrice - target variable

```{r}
summary(all$SalePrice)

ggplot(all[!is.na(all$SalePrice),], aes(x=SalePrice)) +
  geom_histogram(fill="red") +
  scale_x_continuous(breaks = seq(0,800000, by=100000), labels = scales::comma) #library(scales)
```

SalePrice의 분포를 보면, right-skewed된 분포임을 알 수 있다. 분산 안정화를 위해 log를 취하여 그래프를 그려보면,


```{r}
summary(log(all$SalePrice))

ggplot(all[!is.na(all$SalePrice),], aes(x=log(SalePrice))) +
  geom_histogram(fill="red") +
  scale_x_continuous(breaks = seq(10,15, by=0.25))
```

평균이 12.02이고 어느 쪽으로 skewed된 경향이 감소했음을 알 수 있었다.

## attribute values (Imputation) {.tabset}

이제 attribute values를 살펴보기 전에, 결측값이 존재하는지 아닌지 알아보았다.

```{r}
NAs <- function(df){
  aa <- sapply(df, function(x){sum(is.na(x))})
  return(sort(aa[which(aa>0)], decreasing = T))
}

NAs(all)
```
 
관련있는 변수끼리 묶에 결측치 처리 (imputation)을 한다.
참고로 SalePrice의 1459개는 test의 갯수로 예측해야 하는 종속변수이므로 imputation하지 않는다.

### Pool
PoolQC : Pool quality

       Ex	Excellent
       Gd	Good
       TA	Average/Typical
       Fa	Fair
       NA	No Pool
       
PoolQC는 전체 2919개 중 10개를 제외한 나머지는 결측으로 처리되어 있다. 이를 NA에서 None 즉 pool이 없다고 바꿔준다.

```{r}
all$PoolQC[is.na(all$PoolQC)] <- 'None'
```

* 에러가 날 경우 


    invalid factor level, NA generated
    

이거는 이미 PoolQC의 class가 factor이며, level이 Ex, Fa, Gd로 설정되있는 상태에서, None 이라는 새로운 level을 넣을 경우 에러로 뜬다. 따라서 처음 데이터를 불러올 때 "stringsAsFactors = F" 설정을 넣어 str class로 범주형 변수를 불러온다. (그 증거로, "stringsAsFactors = F" 없는 경우 str() 함수를 쓸 경우 범주형 변수가 Factor로 설정되는 반면, "stringsAsFactors = F" 있는 경우 범주형 변수가 str 형식으로 설정된다.) 그런 뒤 각 변수의 imputation과정을 거치고 factor로 바꿔준다.

그런 뒤 새로 Factor로 변환시키는데, level을 지정해준다. 순서형 변수이므로 순서로 변환.

```{r}
library(plyr)
Qualities <- c('None'=0, 'Po'=1, "Fa"=2, "TA"=3, "Gd"=4, "Ex"=5)
all$PoolQC <- as.integer(revalue(all$PoolQC, replace=Qualities))
table(all$PoolQC)
```


PoolArea 에 값이 있으면 PoolQC는 무조건 1 이상이어야 하지만, 0의 값을 갖는 값들이 있었다. 

```{r}
all[all$PoolArea>0 & all$PoolQC==0, c("PoolArea","PoolQC","OverallQual")]
```
 
이를 보정해주었다. OverallQual은 집의 전반적인 퀄리티를 나타내는 변수로, 이를 이용해 적절하게 보정하였다.

```{r}
all$PoolQC[2421] <- 2
all$PoolQC[2504] <- 3
all$PoolQC[2600] <- 2
```
 
### Miscellaneous

       Elev	Elevator
       Gar2	2nd Garage (if not described in garage section)
       Othr	Other
       Shed	Shed (over 100 SF)
       TenC	Tennis Court
       NA	None

```{r}
all$MiscFeature[is.na(all$MiscFeature)] <- 'None'
all$MiscFeature <- as.factor(all$MiscFeature)


ggplot(all[all$SalePrice,], aes(x=MiscFeature, y=SalePrice)) +
  geom_bar(stat='summary', fun.y='median', fill='blue') +
  scale_y_continuous(breaks = seq(0,80000, by=10000), labels = ::comma) +
  geom_label(stat="count", aes(label=..count.., y=..count..))
```







 
 
 
 
 
 
